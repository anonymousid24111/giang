{ 
    "_id" : ObjectId("5ead4d9dbe233f0367a66a1d"), 
    "type" : "img", 
    "name" : "Test image", 
    "link" : "test.img", 
    "modified" : "Sat May 02 2020 17:38:21 GMT+0700 (SE Asia Standard Time)", 
    "location" : "team1"
}
{ 
    "_id" : ObjectId("5ead4d9dbe233f0367a66a1e"), 
    "type" : "pdf", 
    "name" : "Test pdf", 
    "link" : "test.pdf", 
    "modified" : "1/5/2020", 
    "location" : "team2"
}
{ 
    "_id" : ObjectId("5ead4d9dbe233f0367a66a1f"), 
    "type" : "docx", 
    "name" : "Test docx", 
    "link" : "test.docx", 
    "modified" : "1/5/2020", 
    "location" : "team3"
}
{ 
    "_id" : ObjectId("5ead4d9dbe233f0367a66a20"), 
    "type" : "txt", 
    "name" : "Test txt", 
    "link" : "test.txt", 
    "modified" : "2/5/2020", 
    "location" : "team1"
}
{ 
    "_id" : ObjectId("5ead4d9dbe233f0367a66a21"), 
    "test" : {
        "_mongo" : {
            "slaveOk" : false, 
            "host" : "127.0.0.1:27017", 
            "defaultDB" : "test", 
            "_defaultSession" : {
                "_serverSession" : {
                    "handle" : {

                    }, 
                    "isTxnActive" : function isTxnActive() {
            return hasTxnState("active");
        }, 
                    "isFirstStatement" : function isFirstStatement() {
            return _nextStatementId === 0;
        }, 
                    "getLastUsed" : function getLastUsed() {
            return _lastUsed;
        }, 
                    "getTxnNumber" : function getTxnNumber() {
            return this.handle.getTxnNumber();
        }, 
                    "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
            this.handle.setTxnNumber(newTxnNumber);
        }, 
                    "getTxnOptions" : function getTxnOptions() {
            return _txnOptions;
        }, 
                    "injectSessionId" : function injectSessionId(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("lsid")) {
                if (isAcknowledged(cmdObjUnwrapped)) {
                    cmdObjUnwrapped.lsid = this.handle.getId();
                }

                // We consider the session to still be in use by the client any time the session id
                // is injected into the command object as part of making a request.
                updateLastUsed();
            }

            return cmdObj;
        }, 
                    "assignTransactionNumber" : function assignTransactionNumber(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                this.handle.incrementTxnNumber();
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            return cmdObj;
        }, 
                    "assignTxnInfo" : function assignTxnInfo(cmdObj) {
            // We will want to reset the transaction state to 'inactive' if a normal operation
            // follows a committed or aborted transaction.
            if ((hasTxnState("aborted")) ||
                (hasTxnState("committed") && Object.keys(cmdObj)[0] !== "commitTransaction")) {
                setTxnState("inactive");
            }

            // If we're not in an active transaction or performing a retry on commitTransaction,
            // return early.
            if (hasTxnState("inactive")) {
                return cmdObj;
            }

            // If we reconnect to a 3.6 server in the middle of a transaction, we
            // catch it here.
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                setTxnState("inactive");
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            // All operations of a multi-statement transaction must specify autocommit=false.
            cmdObjUnwrapped.autocommit = false;

            // Statement Id is required on all transaction operations.
            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);

            // 'readConcern' and 'startTransaction' can only be specified on the first statement
            // in a transaction.
            if (_nextStatementId == 0) {
                cmdObjUnwrapped.startTransaction = true;
                if (_txnOptions.getTxnReadConcern() !== undefined) {
                    // Override the readConcern with the one specified during startTransaction.
                    cmdObjUnwrapped.readConcern = Object.assign(
                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());
                }
            }

            // Reserve the statement ids for batch writes.
            switch (cmdName) {
                case "insert":
                    _nextStatementId += cmdObjUnwrapped.documents.length;
                    break;
                case "update":
                    _nextStatementId += cmdObjUnwrapped.updates.length;
                    break;
                case "delete":
                    _nextStatementId += cmdObjUnwrapped.deletes.length;
                    break;
                default:
                    _nextStatementId += 1;
            }

            return cmdObj;
        }, 
                    "startTransaction" : function startTransaction(txnOptsObj, ignoreActiveTxn) {
            // If the session is already in a transaction, raise an error. If ignoreActiveTxn
            // is true, don't raise an error. This is to allow multiple threads to try to
            // use the same session in a concurrency workload.
            if (this.isTxnActive() && !ignoreActiveTxn) {
                throw new Error("Transaction already in progress on this session.");
            }
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            _txnOptions = new TransactionOptions(txnOptsObj);
            setTxnState("active");
            _nextStatementId = 0;
            this.handle.incrementTxnNumber();
        }, 
                    "commitTransaction" : function commitTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to commit it.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call commitTransaction after calling abortTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to commit on this session.");
            }
            // run commitTxn command
            return endTransaction("commitTransaction", driverSession);
        }, 
                    "abortTransaction" : function abortTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to abort it again.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call abortTransaction twice.");
            }
            // We cannot attempt to abort a transaction that has already been committed.
            if (hasTxnState("committed")) {
                throw new Error("Cannot call abortTransaction after calling commitTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to abort on this session.");
            }
            // run abortTxn command
            return endTransaction("abortTransaction", driverSession);
        }, 
                    "getTxnWriteConcern" : function getTxnWriteConcern(driverSession) {
            // If a writeConcern is not specified from the default transaction options, it will be
            // inherited from the session.
            let writeConcern = undefined;
            const sessionAwareClient = driverSession._getSessionAwareClient();
            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {
                writeConcern = sessionAwareClient.getWriteConcern(driverSession);
            }
            if (_txnOptions.getTxnWriteConcern() !== undefined) {
                writeConcern = _txnOptions.getTxnWriteConcern();
            }
            return writeConcern;
        }
                }, 
                "_isExplicit" : false, 
                "getClient" : function getClient() {
                return client;
            }, 
                "_getSessionAwareClient" : function _getSessionAwareClient() {
                return sessionAwareClient;
            }, 
                "getOptions" : function getOptions() {
                return _options;
            }, 
                "getSessionId" : function getSessionId() {
                if (!this._serverSession.hasOwnProperty("handle")) {
                    return null;
                }
                return this._serverSession.handle.getId();
            }, 
                "getTxnNumber_forTesting" : function getTxnNumber_forTesting() {
                return this._serverSession.getTxnNumber();
            }, 
                "getTxnWriteConcern_forTesting" : function getTxnWriteConcern_forTesting() {
                return this._serverSession.getTxnWriteConcern(this);
            }, 
                "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
                this._serverSession.setTxnNumber_forTesting(newTxnNumber);
            }, 
                "getOperationTime" : function getOperationTime() {
                return _operationTime;
            }, 
                "advanceOperationTime" : function advanceOperationTime(operationTime) {
                if (!isNonNullObject(_operationTime) ||
                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {
                    _operationTime = operationTime;
                }
            }, 
                "resetOperationTime_forTesting" : function resetOperationTime_forTesting() {
                _operationTime = undefined;
            }, 
                "getClusterTime" : function getClusterTime() {
                return _clusterTime;
            }, 
                "advanceClusterTime" : function advanceClusterTime(clusterTime) {
                if (!isNonNullObject(_clusterTime) ||
                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >
                        0) {
                    _clusterTime = clusterTime;
                }
            }, 
                "resetClusterTime_forTesting" : function resetClusterTime_forTesting() {
                _clusterTime = undefined;
            }, 
                "getDatabase" : function getDatabase(dbName) {
                const db = client.getDB(dbName);
                db._session = this;
                return db;
            }, 
                "hasEnded" : function hasEnded() {
                return _hasEnded;
            }, 
                "endSession" : function endSession() {
                if (this._hasEnded) {
                    return;
                }

                this._hasEnded = true;
                implMethods.endSession(this._serverSession);
            }, 
                "shellPrint" : function() {
                return this.toString();
            }, 
                "tojson" : function _tojson(...args) {
                return tojson(this.getSessionId(), ...args);
            }, 
                "toString" : function toString() {
                const sessionId = this.getSessionId();
                if (sessionId === null) {
                    return "dummy session";
                }
                return "session " + tojson(sessionId);
            }, 
                "startTransaction" : function startTransaction(txnOptsObj = {}) {
                this._serverSession.startTransaction(txnOptsObj);
            }, 
                "startTransaction_forTesting" : function startTransaction_forTesting(
                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {
                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);
            }, 
                "commitTransaction" : function commitTransaction() {
                assert.commandWorked(this._serverSession.commitTransaction(this));
            }, 
                "abortTransaction" : function abortTransaction() {
                // Intentionally ignore command result.
                this._serverSession.abortTransaction(this);
            }, 
                "commitTransaction_forTesting" : function commitTransaction_forTesting() {
                return this._serverSession.commitTransaction(this);
            }, 
                "abortTransaction_forTesting" : function abortTransaction_forTesting() {
                return this._serverSession.abortTransaction(this);
            }, 
                "processCommandResponse_forTesting" : function processCommandResponse_forTesting(
                res) {
                processCommandResponse(this, client, res);
            }
            }, 
            "_readMode" : "commands", 
            "promptPrefix" : "", 
            "authStatus" : {
                "authRequired" : true, 
                "replSetGetStatus" : false, 
                "isMaster" : true
            }, 
            "_writeMode" : "commands"
        }, 
        "_db" : {
            "_mongo" : {
                "slaveOk" : false, 
                "host" : "127.0.0.1:27017", 
                "defaultDB" : "test", 
                "_defaultSession" : {
                    "_serverSession" : {
                        "handle" : {

                        }, 
                        "isTxnActive" : function isTxnActive() {
            return hasTxnState("active");
        }, 
                        "isFirstStatement" : function isFirstStatement() {
            return _nextStatementId === 0;
        }, 
                        "getLastUsed" : function getLastUsed() {
            return _lastUsed;
        }, 
                        "getTxnNumber" : function getTxnNumber() {
            return this.handle.getTxnNumber();
        }, 
                        "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
            this.handle.setTxnNumber(newTxnNumber);
        }, 
                        "getTxnOptions" : function getTxnOptions() {
            return _txnOptions;
        }, 
                        "injectSessionId" : function injectSessionId(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("lsid")) {
                if (isAcknowledged(cmdObjUnwrapped)) {
                    cmdObjUnwrapped.lsid = this.handle.getId();
                }

                // We consider the session to still be in use by the client any time the session id
                // is injected into the command object as part of making a request.
                updateLastUsed();
            }

            return cmdObj;
        }, 
                        "assignTransactionNumber" : function assignTransactionNumber(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                this.handle.incrementTxnNumber();
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            return cmdObj;
        }, 
                        "assignTxnInfo" : function assignTxnInfo(cmdObj) {
            // We will want to reset the transaction state to 'inactive' if a normal operation
            // follows a committed or aborted transaction.
            if ((hasTxnState("aborted")) ||
                (hasTxnState("committed") && Object.keys(cmdObj)[0] !== "commitTransaction")) {
                setTxnState("inactive");
            }

            // If we're not in an active transaction or performing a retry on commitTransaction,
            // return early.
            if (hasTxnState("inactive")) {
                return cmdObj;
            }

            // If we reconnect to a 3.6 server in the middle of a transaction, we
            // catch it here.
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                setTxnState("inactive");
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            // All operations of a multi-statement transaction must specify autocommit=false.
            cmdObjUnwrapped.autocommit = false;

            // Statement Id is required on all transaction operations.
            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);

            // 'readConcern' and 'startTransaction' can only be specified on the first statement
            // in a transaction.
            if (_nextStatementId == 0) {
                cmdObjUnwrapped.startTransaction = true;
                if (_txnOptions.getTxnReadConcern() !== undefined) {
                    // Override the readConcern with the one specified during startTransaction.
                    cmdObjUnwrapped.readConcern = Object.assign(
                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());
                }
            }

            // Reserve the statement ids for batch writes.
            switch (cmdName) {
                case "insert":
                    _nextStatementId += cmdObjUnwrapped.documents.length;
                    break;
                case "update":
                    _nextStatementId += cmdObjUnwrapped.updates.length;
                    break;
                case "delete":
                    _nextStatementId += cmdObjUnwrapped.deletes.length;
                    break;
                default:
                    _nextStatementId += 1;
            }

            return cmdObj;
        }, 
                        "startTransaction" : function startTransaction(txnOptsObj, ignoreActiveTxn) {
            // If the session is already in a transaction, raise an error. If ignoreActiveTxn
            // is true, don't raise an error. This is to allow multiple threads to try to
            // use the same session in a concurrency workload.
            if (this.isTxnActive() && !ignoreActiveTxn) {
                throw new Error("Transaction already in progress on this session.");
            }
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            _txnOptions = new TransactionOptions(txnOptsObj);
            setTxnState("active");
            _nextStatementId = 0;
            this.handle.incrementTxnNumber();
        }, 
                        "commitTransaction" : function commitTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to commit it.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call commitTransaction after calling abortTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to commit on this session.");
            }
            // run commitTxn command
            return endTransaction("commitTransaction", driverSession);
        }, 
                        "abortTransaction" : function abortTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to abort it again.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call abortTransaction twice.");
            }
            // We cannot attempt to abort a transaction that has already been committed.
            if (hasTxnState("committed")) {
                throw new Error("Cannot call abortTransaction after calling commitTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to abort on this session.");
            }
            // run abortTxn command
            return endTransaction("abortTransaction", driverSession);
        }, 
                        "getTxnWriteConcern" : function getTxnWriteConcern(driverSession) {
            // If a writeConcern is not specified from the default transaction options, it will be
            // inherited from the session.
            let writeConcern = undefined;
            const sessionAwareClient = driverSession._getSessionAwareClient();
            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {
                writeConcern = sessionAwareClient.getWriteConcern(driverSession);
            }
            if (_txnOptions.getTxnWriteConcern() !== undefined) {
                writeConcern = _txnOptions.getTxnWriteConcern();
            }
            return writeConcern;
        }
                    }, 
                    "_isExplicit" : false, 
                    "getClient" : function getClient() {
                return client;
            }, 
                    "_getSessionAwareClient" : function _getSessionAwareClient() {
                return sessionAwareClient;
            }, 
                    "getOptions" : function getOptions() {
                return _options;
            }, 
                    "getSessionId" : function getSessionId() {
                if (!this._serverSession.hasOwnProperty("handle")) {
                    return null;
                }
                return this._serverSession.handle.getId();
            }, 
                    "getTxnNumber_forTesting" : function getTxnNumber_forTesting() {
                return this._serverSession.getTxnNumber();
            }, 
                    "getTxnWriteConcern_forTesting" : function getTxnWriteConcern_forTesting() {
                return this._serverSession.getTxnWriteConcern(this);
            }, 
                    "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
                this._serverSession.setTxnNumber_forTesting(newTxnNumber);
            }, 
                    "getOperationTime" : function getOperationTime() {
                return _operationTime;
            }, 
                    "advanceOperationTime" : function advanceOperationTime(operationTime) {
                if (!isNonNullObject(_operationTime) ||
                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {
                    _operationTime = operationTime;
                }
            }, 
                    "resetOperationTime_forTesting" : function resetOperationTime_forTesting() {
                _operationTime = undefined;
            }, 
                    "getClusterTime" : function getClusterTime() {
                return _clusterTime;
            }, 
                    "advanceClusterTime" : function advanceClusterTime(clusterTime) {
                if (!isNonNullObject(_clusterTime) ||
                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >
                        0) {
                    _clusterTime = clusterTime;
                }
            }, 
                    "resetClusterTime_forTesting" : function resetClusterTime_forTesting() {
                _clusterTime = undefined;
            }, 
                    "getDatabase" : function getDatabase(dbName) {
                const db = client.getDB(dbName);
                db._session = this;
                return db;
            }, 
                    "hasEnded" : function hasEnded() {
                return _hasEnded;
            }, 
                    "endSession" : function endSession() {
                if (this._hasEnded) {
                    return;
                }

                this._hasEnded = true;
                implMethods.endSession(this._serverSession);
            }, 
                    "shellPrint" : function() {
                return this.toString();
            }, 
                    "tojson" : function _tojson(...args) {
                return tojson(this.getSessionId(), ...args);
            }, 
                    "toString" : function toString() {
                const sessionId = this.getSessionId();
                if (sessionId === null) {
                    return "dummy session";
                }
                return "session " + tojson(sessionId);
            }, 
                    "startTransaction" : function startTransaction(txnOptsObj = {}) {
                this._serverSession.startTransaction(txnOptsObj);
            }, 
                    "startTransaction_forTesting" : function startTransaction_forTesting(
                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {
                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);
            }, 
                    "commitTransaction" : function commitTransaction() {
                assert.commandWorked(this._serverSession.commitTransaction(this));
            }, 
                    "abortTransaction" : function abortTransaction() {
                // Intentionally ignore command result.
                this._serverSession.abortTransaction(this);
            }, 
                    "commitTransaction_forTesting" : function commitTransaction_forTesting() {
                return this._serverSession.commitTransaction(this);
            }, 
                    "abortTransaction_forTesting" : function abortTransaction_forTesting() {
                return this._serverSession.abortTransaction(this);
            }, 
                    "processCommandResponse_forTesting" : function processCommandResponse_forTesting(
                res) {
                processCommandResponse(this, client, res);
            }
                }, 
                "_readMode" : "commands", 
                "promptPrefix" : "", 
                "authStatus" : {
                    "authRequired" : true, 
                    "replSetGetStatus" : false, 
                    "isMaster" : true
                }, 
                "_writeMode" : "commands"
            }, 
            "_name" : "project2", 
            "_session" : {
                "_serverSession" : {
                    "handle" : {

                    }, 
                    "isTxnActive" : function isTxnActive() {
            return hasTxnState("active");
        }, 
                    "isFirstStatement" : function isFirstStatement() {
            return _nextStatementId === 0;
        }, 
                    "getLastUsed" : function getLastUsed() {
            return _lastUsed;
        }, 
                    "getTxnNumber" : function getTxnNumber() {
            return this.handle.getTxnNumber();
        }, 
                    "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
            this.handle.setTxnNumber(newTxnNumber);
        }, 
                    "getTxnOptions" : function getTxnOptions() {
            return _txnOptions;
        }, 
                    "injectSessionId" : function injectSessionId(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("lsid")) {
                if (isAcknowledged(cmdObjUnwrapped)) {
                    cmdObjUnwrapped.lsid = this.handle.getId();
                }

                // We consider the session to still be in use by the client any time the session id
                // is injected into the command object as part of making a request.
                updateLastUsed();
            }

            return cmdObj;
        }, 
                    "assignTransactionNumber" : function assignTransactionNumber(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                this.handle.incrementTxnNumber();
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            return cmdObj;
        }, 
                    "assignTxnInfo" : function assignTxnInfo(cmdObj) {
            // We will want to reset the transaction state to 'inactive' if a normal operation
            // follows a committed or aborted transaction.
            if ((hasTxnState("aborted")) ||
                (hasTxnState("committed") && Object.keys(cmdObj)[0] !== "commitTransaction")) {
                setTxnState("inactive");
            }

            // If we're not in an active transaction or performing a retry on commitTransaction,
            // return early.
            if (hasTxnState("inactive")) {
                return cmdObj;
            }

            // If we reconnect to a 3.6 server in the middle of a transaction, we
            // catch it here.
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                setTxnState("inactive");
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            // All operations of a multi-statement transaction must specify autocommit=false.
            cmdObjUnwrapped.autocommit = false;

            // Statement Id is required on all transaction operations.
            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);

            // 'readConcern' and 'startTransaction' can only be specified on the first statement
            // in a transaction.
            if (_nextStatementId == 0) {
                cmdObjUnwrapped.startTransaction = true;
                if (_txnOptions.getTxnReadConcern() !== undefined) {
                    // Override the readConcern with the one specified during startTransaction.
                    cmdObjUnwrapped.readConcern = Object.assign(
                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());
                }
            }

            // Reserve the statement ids for batch writes.
            switch (cmdName) {
                case "insert":
                    _nextStatementId += cmdObjUnwrapped.documents.length;
                    break;
                case "update":
                    _nextStatementId += cmdObjUnwrapped.updates.length;
                    break;
                case "delete":
                    _nextStatementId += cmdObjUnwrapped.deletes.length;
                    break;
                default:
                    _nextStatementId += 1;
            }

            return cmdObj;
        }, 
                    "startTransaction" : function startTransaction(txnOptsObj, ignoreActiveTxn) {
            // If the session is already in a transaction, raise an error. If ignoreActiveTxn
            // is true, don't raise an error. This is to allow multiple threads to try to
            // use the same session in a concurrency workload.
            if (this.isTxnActive() && !ignoreActiveTxn) {
                throw new Error("Transaction already in progress on this session.");
            }
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            _txnOptions = new TransactionOptions(txnOptsObj);
            setTxnState("active");
            _nextStatementId = 0;
            this.handle.incrementTxnNumber();
        }, 
                    "commitTransaction" : function commitTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to commit it.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call commitTransaction after calling abortTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to commit on this session.");
            }
            // run commitTxn command
            return endTransaction("commitTransaction", driverSession);
        }, 
                    "abortTransaction" : function abortTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to abort it again.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call abortTransaction twice.");
            }
            // We cannot attempt to abort a transaction that has already been committed.
            if (hasTxnState("committed")) {
                throw new Error("Cannot call abortTransaction after calling commitTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to abort on this session.");
            }
            // run abortTxn command
            return endTransaction("abortTransaction", driverSession);
        }, 
                    "getTxnWriteConcern" : function getTxnWriteConcern(driverSession) {
            // If a writeConcern is not specified from the default transaction options, it will be
            // inherited from the session.
            let writeConcern = undefined;
            const sessionAwareClient = driverSession._getSessionAwareClient();
            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {
                writeConcern = sessionAwareClient.getWriteConcern(driverSession);
            }
            if (_txnOptions.getTxnWriteConcern() !== undefined) {
                writeConcern = _txnOptions.getTxnWriteConcern();
            }
            return writeConcern;
        }
                }, 
                "_isExplicit" : false, 
                "getClient" : function getClient() {
                return client;
            }, 
                "_getSessionAwareClient" : function _getSessionAwareClient() {
                return sessionAwareClient;
            }, 
                "getOptions" : function getOptions() {
                return _options;
            }, 
                "getSessionId" : function getSessionId() {
                if (!this._serverSession.hasOwnProperty("handle")) {
                    return null;
                }
                return this._serverSession.handle.getId();
            }, 
                "getTxnNumber_forTesting" : function getTxnNumber_forTesting() {
                return this._serverSession.getTxnNumber();
            }, 
                "getTxnWriteConcern_forTesting" : function getTxnWriteConcern_forTesting() {
                return this._serverSession.getTxnWriteConcern(this);
            }, 
                "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
                this._serverSession.setTxnNumber_forTesting(newTxnNumber);
            }, 
                "getOperationTime" : function getOperationTime() {
                return _operationTime;
            }, 
                "advanceOperationTime" : function advanceOperationTime(operationTime) {
                if (!isNonNullObject(_operationTime) ||
                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {
                    _operationTime = operationTime;
                }
            }, 
                "resetOperationTime_forTesting" : function resetOperationTime_forTesting() {
                _operationTime = undefined;
            }, 
                "getClusterTime" : function getClusterTime() {
                return _clusterTime;
            }, 
                "advanceClusterTime" : function advanceClusterTime(clusterTime) {
                if (!isNonNullObject(_clusterTime) ||
                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >
                        0) {
                    _clusterTime = clusterTime;
                }
            }, 
                "resetClusterTime_forTesting" : function resetClusterTime_forTesting() {
                _clusterTime = undefined;
            }, 
                "getDatabase" : function getDatabase(dbName) {
                const db = client.getDB(dbName);
                db._session = this;
                return db;
            }, 
                "hasEnded" : function hasEnded() {
                return _hasEnded;
            }, 
                "endSession" : function endSession() {
                if (this._hasEnded) {
                    return;
                }

                this._hasEnded = true;
                implMethods.endSession(this._serverSession);
            }, 
                "shellPrint" : function() {
                return this.toString();
            }, 
                "tojson" : function _tojson(...args) {
                return tojson(this.getSessionId(), ...args);
            }, 
                "toString" : function toString() {
                const sessionId = this.getSessionId();
                if (sessionId === null) {
                    return "dummy session";
                }
                return "session " + tojson(sessionId);
            }, 
                "startTransaction" : function startTransaction(txnOptsObj = {}) {
                this._serverSession.startTransaction(txnOptsObj);
            }, 
                "startTransaction_forTesting" : function startTransaction_forTesting(
                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {
                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);
            }, 
                "commitTransaction" : function commitTransaction() {
                assert.commandWorked(this._serverSession.commitTransaction(this));
            }, 
                "abortTransaction" : function abortTransaction() {
                // Intentionally ignore command result.
                this._serverSession.abortTransaction(this);
            }, 
                "commitTransaction_forTesting" : function commitTransaction_forTesting() {
                return this._serverSession.commitTransaction(this);
            }, 
                "abortTransaction_forTesting" : function abortTransaction_forTesting() {
                return this._serverSession.abortTransaction(this);
            }, 
                "processCommandResponse_forTesting" : function processCommandResponse_forTesting(
                res) {
                processCommandResponse(this, client, res);
            }
            }
        }, 
        "_collection" : {
            "_mongo" : {
                "slaveOk" : false, 
                "host" : "127.0.0.1:27017", 
                "defaultDB" : "test", 
                "_defaultSession" : {
                    "_serverSession" : {
                        "handle" : {

                        }, 
                        "isTxnActive" : function isTxnActive() {
            return hasTxnState("active");
        }, 
                        "isFirstStatement" : function isFirstStatement() {
            return _nextStatementId === 0;
        }, 
                        "getLastUsed" : function getLastUsed() {
            return _lastUsed;
        }, 
                        "getTxnNumber" : function getTxnNumber() {
            return this.handle.getTxnNumber();
        }, 
                        "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
            this.handle.setTxnNumber(newTxnNumber);
        }, 
                        "getTxnOptions" : function getTxnOptions() {
            return _txnOptions;
        }, 
                        "injectSessionId" : function injectSessionId(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("lsid")) {
                if (isAcknowledged(cmdObjUnwrapped)) {
                    cmdObjUnwrapped.lsid = this.handle.getId();
                }

                // We consider the session to still be in use by the client any time the session id
                // is injected into the command object as part of making a request.
                updateLastUsed();
            }

            return cmdObj;
        }, 
                        "assignTransactionNumber" : function assignTransactionNumber(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                this.handle.incrementTxnNumber();
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            return cmdObj;
        }, 
                        "assignTxnInfo" : function assignTxnInfo(cmdObj) {
            // We will want to reset the transaction state to 'inactive' if a normal operation
            // follows a committed or aborted transaction.
            if ((hasTxnState("aborted")) ||
                (hasTxnState("committed") && Object.keys(cmdObj)[0] !== "commitTransaction")) {
                setTxnState("inactive");
            }

            // If we're not in an active transaction or performing a retry on commitTransaction,
            // return early.
            if (hasTxnState("inactive")) {
                return cmdObj;
            }

            // If we reconnect to a 3.6 server in the middle of a transaction, we
            // catch it here.
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                setTxnState("inactive");
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            // All operations of a multi-statement transaction must specify autocommit=false.
            cmdObjUnwrapped.autocommit = false;

            // Statement Id is required on all transaction operations.
            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);

            // 'readConcern' and 'startTransaction' can only be specified on the first statement
            // in a transaction.
            if (_nextStatementId == 0) {
                cmdObjUnwrapped.startTransaction = true;
                if (_txnOptions.getTxnReadConcern() !== undefined) {
                    // Override the readConcern with the one specified during startTransaction.
                    cmdObjUnwrapped.readConcern = Object.assign(
                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());
                }
            }

            // Reserve the statement ids for batch writes.
            switch (cmdName) {
                case "insert":
                    _nextStatementId += cmdObjUnwrapped.documents.length;
                    break;
                case "update":
                    _nextStatementId += cmdObjUnwrapped.updates.length;
                    break;
                case "delete":
                    _nextStatementId += cmdObjUnwrapped.deletes.length;
                    break;
                default:
                    _nextStatementId += 1;
            }

            return cmdObj;
        }, 
                        "startTransaction" : function startTransaction(txnOptsObj, ignoreActiveTxn) {
            // If the session is already in a transaction, raise an error. If ignoreActiveTxn
            // is true, don't raise an error. This is to allow multiple threads to try to
            // use the same session in a concurrency workload.
            if (this.isTxnActive() && !ignoreActiveTxn) {
                throw new Error("Transaction already in progress on this session.");
            }
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            _txnOptions = new TransactionOptions(txnOptsObj);
            setTxnState("active");
            _nextStatementId = 0;
            this.handle.incrementTxnNumber();
        }, 
                        "commitTransaction" : function commitTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to commit it.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call commitTransaction after calling abortTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to commit on this session.");
            }
            // run commitTxn command
            return endTransaction("commitTransaction", driverSession);
        }, 
                        "abortTransaction" : function abortTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to abort it again.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call abortTransaction twice.");
            }
            // We cannot attempt to abort a transaction that has already been committed.
            if (hasTxnState("committed")) {
                throw new Error("Cannot call abortTransaction after calling commitTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to abort on this session.");
            }
            // run abortTxn command
            return endTransaction("abortTransaction", driverSession);
        }, 
                        "getTxnWriteConcern" : function getTxnWriteConcern(driverSession) {
            // If a writeConcern is not specified from the default transaction options, it will be
            // inherited from the session.
            let writeConcern = undefined;
            const sessionAwareClient = driverSession._getSessionAwareClient();
            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {
                writeConcern = sessionAwareClient.getWriteConcern(driverSession);
            }
            if (_txnOptions.getTxnWriteConcern() !== undefined) {
                writeConcern = _txnOptions.getTxnWriteConcern();
            }
            return writeConcern;
        }
                    }, 
                    "_isExplicit" : false, 
                    "getClient" : function getClient() {
                return client;
            }, 
                    "_getSessionAwareClient" : function _getSessionAwareClient() {
                return sessionAwareClient;
            }, 
                    "getOptions" : function getOptions() {
                return _options;
            }, 
                    "getSessionId" : function getSessionId() {
                if (!this._serverSession.hasOwnProperty("handle")) {
                    return null;
                }
                return this._serverSession.handle.getId();
            }, 
                    "getTxnNumber_forTesting" : function getTxnNumber_forTesting() {
                return this._serverSession.getTxnNumber();
            }, 
                    "getTxnWriteConcern_forTesting" : function getTxnWriteConcern_forTesting() {
                return this._serverSession.getTxnWriteConcern(this);
            }, 
                    "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
                this._serverSession.setTxnNumber_forTesting(newTxnNumber);
            }, 
                    "getOperationTime" : function getOperationTime() {
                return _operationTime;
            }, 
                    "advanceOperationTime" : function advanceOperationTime(operationTime) {
                if (!isNonNullObject(_operationTime) ||
                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {
                    _operationTime = operationTime;
                }
            }, 
                    "resetOperationTime_forTesting" : function resetOperationTime_forTesting() {
                _operationTime = undefined;
            }, 
                    "getClusterTime" : function getClusterTime() {
                return _clusterTime;
            }, 
                    "advanceClusterTime" : function advanceClusterTime(clusterTime) {
                if (!isNonNullObject(_clusterTime) ||
                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >
                        0) {
                    _clusterTime = clusterTime;
                }
            }, 
                    "resetClusterTime_forTesting" : function resetClusterTime_forTesting() {
                _clusterTime = undefined;
            }, 
                    "getDatabase" : function getDatabase(dbName) {
                const db = client.getDB(dbName);
                db._session = this;
                return db;
            }, 
                    "hasEnded" : function hasEnded() {
                return _hasEnded;
            }, 
                    "endSession" : function endSession() {
                if (this._hasEnded) {
                    return;
                }

                this._hasEnded = true;
                implMethods.endSession(this._serverSession);
            }, 
                    "shellPrint" : function() {
                return this.toString();
            }, 
                    "tojson" : function _tojson(...args) {
                return tojson(this.getSessionId(), ...args);
            }, 
                    "toString" : function toString() {
                const sessionId = this.getSessionId();
                if (sessionId === null) {
                    return "dummy session";
                }
                return "session " + tojson(sessionId);
            }, 
                    "startTransaction" : function startTransaction(txnOptsObj = {}) {
                this._serverSession.startTransaction(txnOptsObj);
            }, 
                    "startTransaction_forTesting" : function startTransaction_forTesting(
                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {
                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);
            }, 
                    "commitTransaction" : function commitTransaction() {
                assert.commandWorked(this._serverSession.commitTransaction(this));
            }, 
                    "abortTransaction" : function abortTransaction() {
                // Intentionally ignore command result.
                this._serverSession.abortTransaction(this);
            }, 
                    "commitTransaction_forTesting" : function commitTransaction_forTesting() {
                return this._serverSession.commitTransaction(this);
            }, 
                    "abortTransaction_forTesting" : function abortTransaction_forTesting() {
                return this._serverSession.abortTransaction(this);
            }, 
                    "processCommandResponse_forTesting" : function processCommandResponse_forTesting(
                res) {
                processCommandResponse(this, client, res);
            }
                }, 
                "_readMode" : "commands", 
                "promptPrefix" : "", 
                "authStatus" : {
                    "authRequired" : true, 
                    "replSetGetStatus" : false, 
                    "isMaster" : true
                }, 
                "_writeMode" : "commands"
            }, 
            "_db" : {
                "_mongo" : {
                    "slaveOk" : false, 
                    "host" : "127.0.0.1:27017", 
                    "defaultDB" : "test", 
                    "_defaultSession" : {
                        "_serverSession" : {
                            "handle" : {

                            }, 
                            "isTxnActive" : function isTxnActive() {
            return hasTxnState("active");
        }, 
                            "isFirstStatement" : function isFirstStatement() {
            return _nextStatementId === 0;
        }, 
                            "getLastUsed" : function getLastUsed() {
            return _lastUsed;
        }, 
                            "getTxnNumber" : function getTxnNumber() {
            return this.handle.getTxnNumber();
        }, 
                            "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
            this.handle.setTxnNumber(newTxnNumber);
        }, 
                            "getTxnOptions" : function getTxnOptions() {
            return _txnOptions;
        }, 
                            "injectSessionId" : function injectSessionId(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("lsid")) {
                if (isAcknowledged(cmdObjUnwrapped)) {
                    cmdObjUnwrapped.lsid = this.handle.getId();
                }

                // We consider the session to still be in use by the client any time the session id
                // is injected into the command object as part of making a request.
                updateLastUsed();
            }

            return cmdObj;
        }, 
                            "assignTransactionNumber" : function assignTransactionNumber(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                this.handle.incrementTxnNumber();
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            return cmdObj;
        }, 
                            "assignTxnInfo" : function assignTxnInfo(cmdObj) {
            // We will want to reset the transaction state to 'inactive' if a normal operation
            // follows a committed or aborted transaction.
            if ((hasTxnState("aborted")) ||
                (hasTxnState("committed") && Object.keys(cmdObj)[0] !== "commitTransaction")) {
                setTxnState("inactive");
            }

            // If we're not in an active transaction or performing a retry on commitTransaction,
            // return early.
            if (hasTxnState("inactive")) {
                return cmdObj;
            }

            // If we reconnect to a 3.6 server in the middle of a transaction, we
            // catch it here.
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                setTxnState("inactive");
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            // All operations of a multi-statement transaction must specify autocommit=false.
            cmdObjUnwrapped.autocommit = false;

            // Statement Id is required on all transaction operations.
            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);

            // 'readConcern' and 'startTransaction' can only be specified on the first statement
            // in a transaction.
            if (_nextStatementId == 0) {
                cmdObjUnwrapped.startTransaction = true;
                if (_txnOptions.getTxnReadConcern() !== undefined) {
                    // Override the readConcern with the one specified during startTransaction.
                    cmdObjUnwrapped.readConcern = Object.assign(
                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());
                }
            }

            // Reserve the statement ids for batch writes.
            switch (cmdName) {
                case "insert":
                    _nextStatementId += cmdObjUnwrapped.documents.length;
                    break;
                case "update":
                    _nextStatementId += cmdObjUnwrapped.updates.length;
                    break;
                case "delete":
                    _nextStatementId += cmdObjUnwrapped.deletes.length;
                    break;
                default:
                    _nextStatementId += 1;
            }

            return cmdObj;
        }, 
                            "startTransaction" : function startTransaction(txnOptsObj, ignoreActiveTxn) {
            // If the session is already in a transaction, raise an error. If ignoreActiveTxn
            // is true, don't raise an error. This is to allow multiple threads to try to
            // use the same session in a concurrency workload.
            if (this.isTxnActive() && !ignoreActiveTxn) {
                throw new Error("Transaction already in progress on this session.");
            }
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            _txnOptions = new TransactionOptions(txnOptsObj);
            setTxnState("active");
            _nextStatementId = 0;
            this.handle.incrementTxnNumber();
        }, 
                            "commitTransaction" : function commitTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to commit it.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call commitTransaction after calling abortTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to commit on this session.");
            }
            // run commitTxn command
            return endTransaction("commitTransaction", driverSession);
        }, 
                            "abortTransaction" : function abortTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to abort it again.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call abortTransaction twice.");
            }
            // We cannot attempt to abort a transaction that has already been committed.
            if (hasTxnState("committed")) {
                throw new Error("Cannot call abortTransaction after calling commitTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to abort on this session.");
            }
            // run abortTxn command
            return endTransaction("abortTransaction", driverSession);
        }, 
                            "getTxnWriteConcern" : function getTxnWriteConcern(driverSession) {
            // If a writeConcern is not specified from the default transaction options, it will be
            // inherited from the session.
            let writeConcern = undefined;
            const sessionAwareClient = driverSession._getSessionAwareClient();
            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {
                writeConcern = sessionAwareClient.getWriteConcern(driverSession);
            }
            if (_txnOptions.getTxnWriteConcern() !== undefined) {
                writeConcern = _txnOptions.getTxnWriteConcern();
            }
            return writeConcern;
        }
                        }, 
                        "_isExplicit" : false, 
                        "getClient" : function getClient() {
                return client;
            }, 
                        "_getSessionAwareClient" : function _getSessionAwareClient() {
                return sessionAwareClient;
            }, 
                        "getOptions" : function getOptions() {
                return _options;
            }, 
                        "getSessionId" : function getSessionId() {
                if (!this._serverSession.hasOwnProperty("handle")) {
                    return null;
                }
                return this._serverSession.handle.getId();
            }, 
                        "getTxnNumber_forTesting" : function getTxnNumber_forTesting() {
                return this._serverSession.getTxnNumber();
            }, 
                        "getTxnWriteConcern_forTesting" : function getTxnWriteConcern_forTesting() {
                return this._serverSession.getTxnWriteConcern(this);
            }, 
                        "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
                this._serverSession.setTxnNumber_forTesting(newTxnNumber);
            }, 
                        "getOperationTime" : function getOperationTime() {
                return _operationTime;
            }, 
                        "advanceOperationTime" : function advanceOperationTime(operationTime) {
                if (!isNonNullObject(_operationTime) ||
                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {
                    _operationTime = operationTime;
                }
            }, 
                        "resetOperationTime_forTesting" : function resetOperationTime_forTesting() {
                _operationTime = undefined;
            }, 
                        "getClusterTime" : function getClusterTime() {
                return _clusterTime;
            }, 
                        "advanceClusterTime" : function advanceClusterTime(clusterTime) {
                if (!isNonNullObject(_clusterTime) ||
                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >
                        0) {
                    _clusterTime = clusterTime;
                }
            }, 
                        "resetClusterTime_forTesting" : function resetClusterTime_forTesting() {
                _clusterTime = undefined;
            }, 
                        "getDatabase" : function getDatabase(dbName) {
                const db = client.getDB(dbName);
                db._session = this;
                return db;
            }, 
                        "hasEnded" : function hasEnded() {
                return _hasEnded;
            }, 
                        "endSession" : function endSession() {
                if (this._hasEnded) {
                    return;
                }

                this._hasEnded = true;
                implMethods.endSession(this._serverSession);
            }, 
                        "shellPrint" : function() {
                return this.toString();
            }, 
                        "tojson" : function _tojson(...args) {
                return tojson(this.getSessionId(), ...args);
            }, 
                        "toString" : function toString() {
                const sessionId = this.getSessionId();
                if (sessionId === null) {
                    return "dummy session";
                }
                return "session " + tojson(sessionId);
            }, 
                        "startTransaction" : function startTransaction(txnOptsObj = {}) {
                this._serverSession.startTransaction(txnOptsObj);
            }, 
                        "startTransaction_forTesting" : function startTransaction_forTesting(
                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {
                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);
            }, 
                        "commitTransaction" : function commitTransaction() {
                assert.commandWorked(this._serverSession.commitTransaction(this));
            }, 
                        "abortTransaction" : function abortTransaction() {
                // Intentionally ignore command result.
                this._serverSession.abortTransaction(this);
            }, 
                        "commitTransaction_forTesting" : function commitTransaction_forTesting() {
                return this._serverSession.commitTransaction(this);
            }, 
                        "abortTransaction_forTesting" : function abortTransaction_forTesting() {
                return this._serverSession.abortTransaction(this);
            }, 
                        "processCommandResponse_forTesting" : function processCommandResponse_forTesting(
                res) {
                processCommandResponse(this, client, res);
            }
                    }, 
                    "_readMode" : "commands", 
                    "promptPrefix" : "", 
                    "authStatus" : {
                        "authRequired" : true, 
                        "replSetGetStatus" : false, 
                        "isMaster" : true
                    }, 
                    "_writeMode" : "commands"
                }, 
                "_name" : "project2", 
                "_session" : {
                    "_serverSession" : {
                        "handle" : {

                        }, 
                        "isTxnActive" : function isTxnActive() {
            return hasTxnState("active");
        }, 
                        "isFirstStatement" : function isFirstStatement() {
            return _nextStatementId === 0;
        }, 
                        "getLastUsed" : function getLastUsed() {
            return _lastUsed;
        }, 
                        "getTxnNumber" : function getTxnNumber() {
            return this.handle.getTxnNumber();
        }, 
                        "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
            this.handle.setTxnNumber(newTxnNumber);
        }, 
                        "getTxnOptions" : function getTxnOptions() {
            return _txnOptions;
        }, 
                        "injectSessionId" : function injectSessionId(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("lsid")) {
                if (isAcknowledged(cmdObjUnwrapped)) {
                    cmdObjUnwrapped.lsid = this.handle.getId();
                }

                // We consider the session to still be in use by the client any time the session id
                // is injected into the command object as part of making a request.
                updateLastUsed();
            }

            return cmdObj;
        }, 
                        "assignTransactionNumber" : function assignTransactionNumber(cmdObj) {
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                this.handle.incrementTxnNumber();
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            return cmdObj;
        }, 
                        "assignTxnInfo" : function assignTxnInfo(cmdObj) {
            // We will want to reset the transaction state to 'inactive' if a normal operation
            // follows a committed or aborted transaction.
            if ((hasTxnState("aborted")) ||
                (hasTxnState("committed") && Object.keys(cmdObj)[0] !== "commitTransaction")) {
                setTxnState("inactive");
            }

            // If we're not in an active transaction or performing a retry on commitTransaction,
            // return early.
            if (hasTxnState("inactive")) {
                return cmdObj;
            }

            // If we reconnect to a 3.6 server in the middle of a transaction, we
            // catch it here.
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                setTxnState("inactive");
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            cmdObj = Object.assign({}, cmdObj);

            const cmdName = Object.keys(cmdObj)[0];

            // If the command is in a wrapped form, then we look for the actual command object
            // inside the query/$query object.
            let cmdObjUnwrapped = cmdObj;
            if (cmdName === "query" || cmdName === "$query") {
                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);
                cmdObjUnwrapped = cmdObj[cmdName];
            }

            if (!cmdObjUnwrapped.hasOwnProperty("txnNumber")) {
                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();
            }

            // All operations of a multi-statement transaction must specify autocommit=false.
            cmdObjUnwrapped.autocommit = false;

            // Statement Id is required on all transaction operations.
            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);

            // 'readConcern' and 'startTransaction' can only be specified on the first statement
            // in a transaction.
            if (_nextStatementId == 0) {
                cmdObjUnwrapped.startTransaction = true;
                if (_txnOptions.getTxnReadConcern() !== undefined) {
                    // Override the readConcern with the one specified during startTransaction.
                    cmdObjUnwrapped.readConcern = Object.assign(
                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());
                }
            }

            // Reserve the statement ids for batch writes.
            switch (cmdName) {
                case "insert":
                    _nextStatementId += cmdObjUnwrapped.documents.length;
                    break;
                case "update":
                    _nextStatementId += cmdObjUnwrapped.updates.length;
                    break;
                case "delete":
                    _nextStatementId += cmdObjUnwrapped.deletes.length;
                    break;
                default:
                    _nextStatementId += 1;
            }

            return cmdObj;
        }, 
                        "startTransaction" : function startTransaction(txnOptsObj, ignoreActiveTxn) {
            // If the session is already in a transaction, raise an error. If ignoreActiveTxn
            // is true, don't raise an error. This is to allow multiple threads to try to
            // use the same session in a concurrency workload.
            if (this.isTxnActive() && !ignoreActiveTxn) {
                throw new Error("Transaction already in progress on this session.");
            }
            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {
                throw new Error(
                    "Transactions are only supported on server versions 4.0 and greater.");
            }
            _txnOptions = new TransactionOptions(txnOptsObj);
            setTxnState("active");
            _nextStatementId = 0;
            this.handle.incrementTxnNumber();
        }, 
                        "commitTransaction" : function commitTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to commit it.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call commitTransaction after calling abortTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to commit on this session.");
            }
            // run commitTxn command
            return endTransaction("commitTransaction", driverSession);
        }, 
                        "abortTransaction" : function abortTransaction(driverSession) {
            // If the transaction state is already 'aborted' we cannot try to abort it again.
            if (hasTxnState("aborted")) {
                throw new Error("Cannot call abortTransaction twice.");
            }
            // We cannot attempt to abort a transaction that has already been committed.
            if (hasTxnState("committed")) {
                throw new Error("Cannot call abortTransaction after calling commitTransaction.");
            }
            // If the session has no active transaction, raise an error.
            if (hasTxnState("inactive")) {
                throw new Error("There is no active transaction to abort on this session.");
            }
            // run abortTxn command
            return endTransaction("abortTransaction", driverSession);
        }, 
                        "getTxnWriteConcern" : function getTxnWriteConcern(driverSession) {
            // If a writeConcern is not specified from the default transaction options, it will be
            // inherited from the session.
            let writeConcern = undefined;
            const sessionAwareClient = driverSession._getSessionAwareClient();
            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {
                writeConcern = sessionAwareClient.getWriteConcern(driverSession);
            }
            if (_txnOptions.getTxnWriteConcern() !== undefined) {
                writeConcern = _txnOptions.getTxnWriteConcern();
            }
            return writeConcern;
        }
                    }, 
                    "_isExplicit" : false, 
                    "getClient" : function getClient() {
                return client;
            }, 
                    "_getSessionAwareClient" : function _getSessionAwareClient() {
                return sessionAwareClient;
            }, 
                    "getOptions" : function getOptions() {
                return _options;
            }, 
                    "getSessionId" : function getSessionId() {
                if (!this._serverSession.hasOwnProperty("handle")) {
                    return null;
                }
                return this._serverSession.handle.getId();
            }, 
                    "getTxnNumber_forTesting" : function getTxnNumber_forTesting() {
                return this._serverSession.getTxnNumber();
            }, 
                    "getTxnWriteConcern_forTesting" : function getTxnWriteConcern_forTesting() {
                return this._serverSession.getTxnWriteConcern(this);
            }, 
                    "setTxnNumber_forTesting" : function setTxnNumber_forTesting(newTxnNumber) {
                this._serverSession.setTxnNumber_forTesting(newTxnNumber);
            }, 
                    "getOperationTime" : function getOperationTime() {
                return _operationTime;
            }, 
                    "advanceOperationTime" : function advanceOperationTime(operationTime) {
                if (!isNonNullObject(_operationTime) ||
                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {
                    _operationTime = operationTime;
                }
            }, 
                    "resetOperationTime_forTesting" : function resetOperationTime_forTesting() {
                _operationTime = undefined;
            }, 
                    "getClusterTime" : function getClusterTime() {
                return _clusterTime;
            }, 
                    "advanceClusterTime" : function advanceClusterTime(clusterTime) {
                if (!isNonNullObject(_clusterTime) ||
                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >
                        0) {
                    _clusterTime = clusterTime;
                }
            }, 
                    "resetClusterTime_forTesting" : function resetClusterTime_forTesting() {
                _clusterTime = undefined;
            }, 
                    "getDatabase" : function getDatabase(dbName) {
                const db = client.getDB(dbName);
                db._session = this;
                return db;
            }, 
                    "hasEnded" : function hasEnded() {
                return _hasEnded;
            }, 
                    "endSession" : function endSession() {
                if (this._hasEnded) {
                    return;
                }

                this._hasEnded = true;
                implMethods.endSession(this._serverSession);
            }, 
                    "shellPrint" : function() {
                return this.toString();
            }, 
                    "tojson" : function _tojson(...args) {
                return tojson(this.getSessionId(), ...args);
            }, 
                    "toString" : function toString() {
                const sessionId = this.getSessionId();
                if (sessionId === null) {
                    return "dummy session";
                }
                return "session " + tojson(sessionId);
            }, 
                    "startTransaction" : function startTransaction(txnOptsObj = {}) {
                this._serverSession.startTransaction(txnOptsObj);
            }, 
                    "startTransaction_forTesting" : function startTransaction_forTesting(
                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {
                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);
            }, 
                    "commitTransaction" : function commitTransaction() {
                assert.commandWorked(this._serverSession.commitTransaction(this));
            }, 
                    "abortTransaction" : function abortTransaction() {
                // Intentionally ignore command result.
                this._serverSession.abortTransaction(this);
            }, 
                    "commitTransaction_forTesting" : function commitTransaction_forTesting() {
                return this._serverSession.commitTransaction(this);
            }, 
                    "abortTransaction_forTesting" : function abortTransaction_forTesting() {
                return this._serverSession.abortTransaction(this);
            }, 
                    "processCommandResponse_forTesting" : function processCommandResponse_forTesting(
                res) {
                processCommandResponse(this, client, res);
            }
                }
            }, 
            "_shortName" : "test", 
            "_fullName" : "project2.test", 
            "_lastID" : undefined
        }, 
        "_ns" : "project2.test", 
        "_query" : {

        }, 
        "_fields" : null, 
        "_limit" : 0.0, 
        "_skip" : 0.0, 
        "_batchSize" : 0.0, 
        "_options" : 0.0, 
        "_cursor" : null, 
        "_numReturned" : 0.0, 
        "_special" : false
    }
}
